/**
 * Keyboard Sequence Configuration Component
 * 
 * Advanced component for configuring keyboard sequences with validation and conflict detection
 */

import React, { useState, useCallback, useEffect, useMemo } from 'react';
import { VaultInfo, ValidationResult } from '../../types';
import { useVault } from '../../contexts';
import { useVaultValidation } from '../../hooks/useVaultValidation';
import { KeyboardSequenceInput } from '../common/KeyboardSequenceInput';

export interface KeyboardSequenceConfigProps {
  value: string;
  onChange: (sequence: string) => void;
  currentVaultId?: string;
  className?: string;
  disabled?: boolean;
  showAdvancedOptions?: boolean;
}

interface SequenceConflict {
  vaultId: string;
  vaultName: string;
  sequence: string;
  similarity: number;
}

/**
 * Keyboard sequence configuration component with advanced validation
 */
export const KeyboardSequenceConfig: React.FC<KeyboardSequenceConfigProps> = ({
  value,
  onChange,
  currentVaultId,
  className = '',
  disabled = false,
  showAdvancedOptions = true,
}) => {
  const { state: vaultState } = useVault();
  const [showConflicts, setShowConflicts] = useState(false);
  const [sequenceMode, setSequenceMode] = useState<'simple' | 'advanced'>('simple');

  // ==================== VALIDATION ====================

  const { validateField, getFieldError, hasFieldError } = useVaultValidation({
    existingVaults: vaultState.vaults,
    currentVaultId,
  });

  const validation = useMemo(() => {
    return validateField('keyboardSequence', value);
  }, [validateField, value]);

  // ==================== CONFLICT DETECTION ====================

  const existingSequences = useMemo(() => {
    return vaultState.vaults
      .filter(vault => vault.id !== currentVaultId)
      .map(vault => ({
        vaultId: vault.id,
        vaultName: vault.name,
        sequence: vault.name, // Simplified - would use actual sequences
      }));
  }, [vaultState.vaults, currentVaultId]);

  const sequenceConflicts = useMemo((): SequenceConflict[] => {
    if (!value || value.length < 2) return [];\n\n    const conflicts: SequenceConflict[] = [];\n    const normalizedValue = value.toLowerCase();\n\n    existingSequences.forEach(({ vaultId, vaultName, sequence }) => {\n      const normalizedSequence = sequence.toLowerCase();\n      \n      // Exact match\n      if (normalizedValue === normalizedSequence) {\n        conflicts.push({\n          vaultId,\n          vaultName,\n          sequence,\n          similarity: 1.0\n        });\n        return;\n      }\n\n      // Substring match\n      if (normalizedValue.includes(normalizedSequence) || normalizedSequence.includes(normalizedValue)) {\n        const similarity = Math.min(normalizedValue.length, normalizedSequence.length) / \n                          Math.max(normalizedValue.length, normalizedSequence.length);\n        \n        if (similarity > 0.7) {\n          conflicts.push({\n            vaultId,\n            vaultName,\n            sequence,\n            similarity\n          });\n        }\n      }\n\n      // Levenshtein distance for similar sequences\n      const distance = calculateLevenshteinDistance(normalizedValue, normalizedSequence);\n      const maxLength = Math.max(normalizedValue.length, normalizedSequence.length);\n      const similarity = 1 - (distance / maxLength);\n      \n      if (similarity > 0.8 && distance <= 2) {\n        conflicts.push({\n          vaultId,\n          vaultName,\n          sequence,\n          similarity\n        });\n      }\n    });\n\n    // Sort by similarity (highest first)\n    return conflicts.sort((a, b) => b.similarity - a.similarity);\n  }, [value, existingSequences]);\n\n  // ==================== SEQUENCE ANALYSIS ====================\n\n  const sequenceAnalysis = useMemo(() => {\n    if (!value) return null;\n\n    const analysis = {\n      length: value.length,\n      hasNumbers: /\\d/.test(value),\n      hasLetters: /[a-zA-Z]/.test(value),\n      hasSymbols: /[!@#$%^&*()_+\\-=\\[\\]{}|;:,.<>?]/.test(value),\n      hasUppercase: /[A-Z]/.test(value),\n      hasLowercase: /[a-z]/.test(value),\n      entropy: calculateEntropy(value),\n      strength: 'weak' as 'weak' | 'medium' | 'strong'\n    };\n\n    // Calculate strength\n    let strengthScore = 0;\n    if (analysis.length >= 4) strengthScore++;\n    if (analysis.length >= 8) strengthScore++;\n    if (analysis.hasNumbers) strengthScore++;\n    if (analysis.hasLetters) strengthScore++;\n    if (analysis.hasSymbols) strengthScore++;\n    if (analysis.hasUppercase && analysis.hasLowercase) strengthScore++;\n    if (analysis.entropy > 3) strengthScore++;\n\n    if (strengthScore >= 6) analysis.strength = 'strong';\n    else if (strengthScore >= 4) analysis.strength = 'medium';\n\n    return analysis;\n  }, [value]);\n\n  // ==================== HANDLERS ====================\n\n  const handleSequenceChange = useCallback((newSequence: string) => {\n    onChange(newSequence);\n    \n    // Auto-show conflicts if any are detected\n    if (newSequence && sequenceConflicts.length > 0) {\n      setShowConflicts(true);\n    }\n  }, [onChange, sequenceConflicts.length]);\n\n  const generateRandomSequence = useCallback(() => {\n    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';\n    let result = '';\n    \n    // Generate 6-8 character sequence\n    const length = 6 + Math.floor(Math.random() * 3);\n    \n    for (let i = 0; i < length; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    \n    // Ensure it doesn't conflict\n    const wouldConflict = existingSequences.some(({ sequence }) => \n      sequence.toLowerCase() === result.toLowerCase()\n    );\n    \n    if (wouldConflict) {\n      // Try again with a different sequence\n      generateRandomSequence();\n    } else {\n      onChange(result);\n    }\n  }, [existingSequences, onChange]);\n\n  const clearSequence = useCallback(() => {\n    onChange('');\n    setShowConflicts(false);\n  }, [onChange]);\n\n  // ==================== RENDER HELPERS ====================\n\n  const renderSequenceAnalysis = () => {\n    if (!sequenceAnalysis) return null;\n\n    const getStrengthColor = (strength: string) => {\n      switch (strength) {\n        case 'strong': return '#4CAF50';\n        case 'medium': return '#FF9800';\n        case 'weak': return '#F44336';\n        default: return '#B4B4B4';\n      }\n    };\n\n    return (\n      <div className=\"sequence-analysis\">\n        <div className=\"analysis-header\">\n          <span className=\"analysis-title\">Sequence Analysis</span>\n          <span \n            className=\"strength-indicator\"\n            style={{ color: getStrengthColor(sequenceAnalysis.strength) }}\n          >\n            {sequenceAnalysis.strength.toUpperCase()}\n          </span>\n        </div>\n        \n        <div className=\"analysis-details\">\n          <div className=\"analysis-row\">\n            <span className=\"analysis-label\">Length:</span>\n            <span className=\"analysis-value\">{sequenceAnalysis.length} characters</span>\n          </div>\n          \n          <div className=\"analysis-row\">\n            <span className=\"analysis-label\">Entropy:</span>\n            <span className=\"analysis-value\">{sequenceAnalysis.entropy.toFixed(2)} bits</span>\n          </div>\n          \n          <div className=\"analysis-features\">\n            {sequenceAnalysis.hasNumbers && <span className=\"feature-tag\">Numbers</span>}\n            {sequenceAnalysis.hasLetters && <span className=\"feature-tag\">Letters</span>}\n            {sequenceAnalysis.hasSymbols && <span className=\"feature-tag\">Symbols</span>}\n            {sequenceAnalysis.hasUppercase && sequenceAnalysis.hasLowercase && \n              <span className=\"feature-tag\">Mixed Case</span>}\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  const renderConflicts = () => {\n    if (sequenceConflicts.length === 0) return null;\n\n    return (\n      <div className=\"sequence-conflicts\">\n        <div className=\"conflicts-header\">\n          <span className=\"conflicts-title\">\n            ⚠️ Potential Conflicts ({sequenceConflicts.length})\n          </span>\n          <button\n            type=\"button\"\n            onClick={() => setShowConflicts(!showConflicts)}\n            className=\"conflicts-toggle\"\n          >\n            {showConflicts ? '▼' : '▶'}\n          </button>\n        </div>\n        \n        {showConflicts && (\n          <div className=\"conflicts-list\">\n            {sequenceConflicts.map((conflict) => (\n              <div key={conflict.vaultId} className=\"conflict-item\">\n                <div className=\"conflict-info\">\n                  <span className=\"conflict-vault\">{conflict.vaultName}</span>\n                  <span className=\"conflict-sequence\">\n                    Sequence: <code>{conflict.sequence}</code>\n                  </span>\n                </div>\n                <div className=\"conflict-similarity\">\n                  {Math.round(conflict.similarity * 100)}% similar\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  const renderAdvancedOptions = () => {\n    if (!showAdvancedOptions) return null;\n\n    return (\n      <div className=\"advanced-options\">\n        <div className=\"options-header\">\n          <span className=\"options-title\">Advanced Options</span>\n        </div>\n        \n        <div className=\"options-content\">\n          <div className=\"option-group\">\n            <label className=\"option-label\">\n              <input\n                type=\"radio\"\n                name=\"sequence-mode\"\n                value=\"simple\"\n                checked={sequenceMode === 'simple'}\n                onChange={(e) => setSequenceMode(e.target.value as 'simple' | 'advanced')}\n                disabled={disabled}\n              />\n              <span className=\"option-text\">Simple Mode</span>\n            </label>\n            <span className=\"option-description\">\n              Basic keyboard sequence for quick access\n            </span>\n          </div>\n          \n          <div className=\"option-group\">\n            <label className=\"option-label\">\n              <input\n                type=\"radio\"\n                name=\"sequence-mode\"\n                value=\"advanced\"\n                checked={sequenceMode === 'advanced'}\n                onChange={(e) => setSequenceMode(e.target.value as 'simple' | 'advanced')}\n                disabled={disabled}\n              />\n              <span className=\"option-text\">Advanced Mode</span>\n            </label>\n            <span className=\"option-description\">\n              Complex sequence with modifiers and special keys\n            </span>\n          </div>\n        </div>\n        \n        <div className=\"options-actions\">\n          <button\n            type=\"button\"\n            onClick={generateRandomSequence}\n            className=\"action-button secondary\"\n            disabled={disabled}\n          >\n            🎲 Generate Random\n          </button>\n          \n          <button\n            type=\"button\"\n            onClick={clearSequence}\n            className=\"action-button secondary\"\n            disabled={disabled || !value}\n          >\n            🗑️ Clear\n          </button>\n        </div>\n      </div>\n    );\n  };\n\n  // ==================== MAIN RENDER ====================\n\n  return (\n    <div className={`keyboard-sequence-config ${className} ${disabled ? 'disabled' : ''}`}>\n      {/* Main Input */}\n      <KeyboardSequenceInput\n        value={value}\n        onChange={handleSequenceChange}\n        existingSequences={existingSequences.map(s => s.sequence)}\n        className={disabled ? 'readonly' : ''}\n      />\n\n      {/* Validation Error */}\n      {!validation.isValid && (\n        <div className=\"validation-error\">\n          <span className=\"error-icon\">⚠️</span>\n          <span className=\"error-message\">{validation.errors[0]?.message}</span>\n        </div>\n      )}\n\n      {/* Sequence Analysis */}\n      {value && renderSequenceAnalysis()}\n\n      {/* Conflicts */}\n      {renderConflicts()}\n\n      {/* Advanced Options */}\n      {renderAdvancedOptions()}\n    </div>\n  );\n};\n\n// ==================== HELPER FUNCTIONS ====================\n\nfunction calculateLevenshteinDistance(str1: string, str2: string): number {\n  const matrix = [];\n  \n  for (let i = 0; i <= str2.length; i++) {\n    matrix[i] = [i];\n  }\n  \n  for (let j = 0; j <= str1.length; j++) {\n    matrix[0][j] = j;\n  }\n  \n  for (let i = 1; i <= str2.length; i++) {\n    for (let j = 1; j <= str1.length; j++) {\n      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1,\n          matrix[i][j - 1] + 1,\n          matrix[i - 1][j] + 1\n        );\n      }\n    }\n  }\n  \n  return matrix[str2.length][str1.length];\n}\n\nfunction calculateEntropy(str: string): number {\n  const charCounts = new Map<string, number>();\n  \n  for (const char of str) {\n    charCounts.set(char, (charCounts.get(char) || 0) + 1);\n  }\n  \n  let entropy = 0;\n  const length = str.length;\n  \n  for (const count of charCounts.values()) {\n    const probability = count / length;\n    entropy -= probability * Math.log2(probability);\n  }\n  \n  return entropy;\n}"